---
title: "Octopus trend simulator 3000"
output: 
  flexdashboard::flex_dashboard:
    theme: lumen
    # temas: default, cerulean, journal, flatly, darkly, readable, spacelab, 
      # united, cosmo, lumen, paper, sandstone, simplex, yeti
    orientation: rows
    vertical_layout: fill
    social: ["twitter", "facebook", "menu"]
    name: 'IPMA'
    source_code: embed
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard) #front-end
library(knitr)
library(DT)
library(rpivotTable)
library(ggplot2)
library(gridExtra)
library(plotly)
library(dplyr)
library(openintro)
library(highcharter)
library(ggvis)
library(leaflet) #mapas
library(sp)
library(shiny) #interface c user
library(zoo) #manipular datas
library(dplyr)
library(trend)

# usado para box-jenkins
# library(forecast)
# library(astsa)

# CMSY
library(R2jags)  # Interface with JAGS
library(coda)
library(gplots)
library(mvtnorm)
library(snpar)
library(neuralnet)
library(conicfit)

# JABBA
library(JABBA)

# usado para spict
library(TMB)
library(spict)
```

```{r load_data}
load('./app_data/data.Rdata')

# Devemos acrescentar 'runtime:shiny' para correr imediatamente a app; para fazer knit e produzir os html necessarios para o github pages, basta tirar essa linha. Quando se reinstala ou actualiza algum package, reiniciar Rstudio antes de fazer publish se não ocorre um bug com as contas.
```

CMSY++ {data-icon="fa-home"}
================================

Column {.sidebar}
------------------------------------------------------

### Inputs

```{r, include = F}
selectInput('cmsy_region',
            label = 'Region',
            choices = c('1-Western Coast','2-Southern Coast'),
            selected = '1-Southern Coast')
selectInput('cmsy_fleet',
            label = 'Fleet',
            choices = c('1-Polyvalent', '2-Bottom Trawl'),
            selected = '1-Polyvalent')

# numericInput('jabba_p_lim',
#             label = 'P_lim',
#             value = 0.5)

# cmsy_dados = reactive({
#   df_effort_y %>% filter(fill == paste(input$cmsy_region, input$cmsy_fleet))
# })

# SETUP CMSY++
options(digits = 3) 
FullSchaefer = F
n.chains   = 2

id = reactive({
  data.frame(Continent = 'Europe',
                Region = 'Iberia',
                Subregion = 'Portugal',
                Stock = paste(input$cmsy_region, input$cmsy_fleet),
                Group = 'Cephalopoda',
                Name = 'Octopus',
                ScientificName = 'Octopus vulgaris',
                SpecCode = 'OCC',
                Source = 'DGRM',
                MinOfYear = 1995,
                MaxOfYear = 2022,
                StartYear = 1995,
                EndYear = 2022,
                Flim = '',
                Fpa = '',
                Blim = '',
                Bmsy = '',
                MSYBtrigger = '',
                Fmsy = '',
                last_F = '',
                Resilience = 'High', #"High”, “Medium”, “Low”, “Very Low”
                r.low = NA,
                r.high = NA,
                stb.low = NA,
                stb.hi = NA,
                int.yr = NA,
                intb.low = NA,
                intb.hi = NA,
                endb.low = NA,
                endb.hi = NA,
                e.creep = TRUE,
                btype = 'CPUE', # 'CPUE', 'None', 'biomass'
                force.cmsy = FALSE,
                Comment = '')
})

catch = reactive({
  data.frame(Stock = df_effort_y$fill,
  # Stock = rep('occ.27.9.a.s.a.mis', nrow(effort_ns)),
                   yr = df_effort_y$year_sale %>% as.character() %>% as.numeric(),
                   ct = df_effort_y$catch/1000,
                   bt = df_effort_y$effort)
})

nn_file     =  "cmsy/ffnn.bin" # file containing neural networks trained to estimate B/k priors
outfile     = paste("Out_",format(Sys.Date(),format="%B%d%Y_"),'text_goes_here',sep="") # default name for output file

stocks = reactive({paste(input$cmsy_region, input$cmsy_fleet)})

#-----------------------------------------
# General settings for the analysis ----
#-----------------------------------------
CV.C         <- 0.15  #><>MSY: Add Catch CV
CV.cpue      <- 0.2 #><>MSY: Add minimum realistic cpue CV
sigmaR       <- 0.1 # overall process error for CMSY; SD=0.1 is the default
cor.log.rk   <- -0.76 # empirical value of log r-k correlation in 250 stocks analyzed with BSM (without r-k correlation), used only in graph
rk.cor.beta  <- c(2.52,3.37) # beta.prior for rk cor+1
nbk          <- 3 # Number of B/k priors to be used by BSM, with options 1 (first year), 2 (first & intermediate), 3 (first, intermediate & final bk priors)
bt4pr        <- F # if TRUE, available abundance data are used for B/k prior settings
auto.start   <- F # if TRUE, start year will be set to first year with intermediate catch to avoid ambiguity between low and high bimass if catches are very low
ct_MSY.lim   <- 1.21  # ct/MSY.pr ratio above which B/k prior is assumed constant
q.biomass.pr <- c(0.9,1.1) # if btype=="biomass" this is the prior range for q
n            <- 5000 # number of points in multivariate cloud in graph panel (b)
ni           <- 3 # iterations for r-k-startbiomass combinations, to test different variability patterns; no improvement seen above 3
nab          <- 3 # recommended=5; minimum number of years with abundance data to run BSM
bw           <- 3 # default bandwidth to be used by ksmooth() for catch data
mgraphs      <- T # set to TRUE to produce additional graphs for management
e.creep.line <- T # set to TRUE to display uncorrected CPUE in biomass graph
kobe.plot    <- T # set to TRUE to produce additional kobe status plot; management graph needs to be TRUE for Kobe to work
BSMfits.plot <- T # set to TRUE to plot fit diagnostics for BSM
pp.plot      <- T # set to TRUE to plot Posterior and Prior distributions for CMSY and BSM
rk.diags     <- T #><>MSY set to TRUE to plot diagnostic plot for r-k space
retros       <- F # set to TRUE to enable retrospective analysis (1-3 years less in the time series)
save.plots   <- F # set to TRUE to save graphs to JPEG files
close.plots  <- F # set to TRUE to close on-screen plots after they are saved, to avoid "too many open devices" error in batch-processing
write.output <- F # set to TRUE if table with results in output file is wanted; expects years 2004-2014 to be available
write.pdf    <- F # set to TRUE if PDF output of results is wanted. See more instructions at end of code.
select.yr    <- NA # option to display F, B, F/Fmsy and B/Bmsy for a certain year; default NA
write.rdata  <- F #><>HW write R data file

#----------------------------------------------
#  FUNCTIONS ----
#----------------------------------------------
#------------------------------------------------------------------------------------
# Function to create multivariate-normal distribution for r-k, used only in graphs
#------------------------------------------------------------------------------------
mvn   <- function(n,mean.log.r,sd.log.r,mean.log.k,sd.log.k) {
  cov.log.rk <- cor.log.rk*sd.log.r*sd.log.k # covariance with empirical correlation and prior variances  covar.log.rk = matrix(NA, ncol=2,nrow=2)   # contract covariance matrix
  covar.log.rk      <- matrix(NA, ncol=2,nrow=2) # covariance matrix
  covar.log.rk[1,1] <- sd.log.r^2                # position [1,1] is variance of log.r
  covar.log.rk[2,2] <- sd.log.k^2               # position [2,2] is variance of log.k
  covar.log.rk[1,2] = covar.log.rk[2,1] = cov.log.rk     # positions [1,2] and [2,1] are correlations
  mu.log.rk  <- (c(mean.log.r,mean.log.k))      # vector of log.means
  mvn.log.rk <- rmvnorm(n,mean=mu.log.rk,sigma=covar.log.rk,method="svd")
  return(mvn.log.rk)
}

#-------------------------------------------------------------
# Function to run Bayesian Schaefer Model (BSM)
#-------------------------------------------------------------
bsm   <- function(ct,btj,nyr,prior.r,prior.k,startbio,q.priorj,
                  init.q,init.r,init.k,pen.bk,pen.F,b.yrs,b.prior,CV.C,CV.cpue,nbk,rk.cor.beta,cmsyjags) {
  #><> convert b.prior ranges into beta priors
  bk.beta = beta.prior(b.prior)

  if(cmsyjags==TRUE ){ nbks=3 } else {nbks = nbk} # Switch between CMSY + BSM

  # Data to be passed on to JAGS
  jags.data        <- c('ct','btj','nyr', 'prior.r', 'prior.k', 'startbio', 'q.priorj',
                        'init.q','init.r','init.k','pen.bk','pen.F','b.yrs','bk.beta','CV.C','CV.cpue','nbks','rk.cor')
  # Parameters to be returned by JAGS #><> HW add key quantaties
  jags.save.params <- c('r','k','q', 'P','ct.jags','cpuem','proc.logB','B','F','BBmsy','FFmsy','ppd.logrk')

  # JAGS model ----
  Model = "model{
    # to reduce chance of non-convergence, Pmean[t] values are forced >= eps
    eps<-0.01
    #><> Add Catch.CV
    for(t in 1:nyr){
      ct.jags[t] ~ dlnorm(log(ct[t]),pow(CV.C,-2))
    }

    penm[1]  <- 0 # no penalty for first biomass
    Pmean[1] <- log(alpha)
    P[1]     ~ dlnorm(Pmean[1],itau2)

    for (t in 2:nyr) {
      Pmean[t] <- ifelse(P[t-1] > 0.25,
        log(max(P[t-1] + r*P[t-1]*(1-P[t-1]) - ct.jags[t-1]/k,eps)),  # Process equation
        log(max(P[t-1] + 4*P[t-1]*r*P[t-1]*(1-P[t-1]) - ct.jags[t-1]/k,eps))) # linear decline of r at B/k < 0.25
      P[t]     ~ dlnorm(Pmean[t],itau2) # Introduce process error
      penm[t]  <- ifelse(P[t]<(eps+0.001),log(q*k*P[t])-log(q*k*(eps+0.001)),
                   # ifelse(P[t]>1,ifelse((ct[t]/max(ct))>0.2,log(q*k*P[t])-log(q*k*(0.99)),0),0)) # penalty if Pmean is outside viable biomass
                    ifelse(P[t]>1.1,log(q*k*P[t])-log(q*k*(0.99)),0))
    }

    # Get Process error deviation
    for(t in 1:nyr){
      proc.logB[t] <- log(P[t]*k)-log(exp(Pmean[t])*k)}

    # ><> b.priors with penalties
    # Biomass priors/penalties are enforced as follows
    for(i in 1:nbks){
    bk.mu[i] ~ dbeta(bk.beta[1,i],bk.beta[2,i])
    bk.beta[3,i] ~ dnorm(bk.mu[i]-P[b.yrs[i]],10000)
    }

    for (t in 1:nyr){
      Fpen[t]   <- ifelse(ct[t]>(0.9*k*P[t]),ct[t]-(0.9*k*P[t]),0) # Penalty term on F > 1, i.e. ct>B
      pen.F[t]  ~ dnorm(Fpen[t],1000)
      pen.bk[t] ~ dnorm(penm[t],10000)
      cpuem[t]  <- log(q*P[t]*k);
      btj[t]     ~ dlnorm(cpuem[t],pow(sigma2,-1));
    }

  # priors
  log.alpha               <- log((startbio[1]+startbio[2])/2) # needed for fit of first biomass
  sd.log.alpha            <- (log.alpha-log(startbio[1]))/4
  tau.log.alpha           <- pow(sd.log.alpha,-2)
  alpha                   ~  dlnorm(log.alpha,tau.log.alpha)

  # set realistic prior for q
  log.qm              <- mean(log(q.priorj))
  sd.log.q            <- (log.qm-log(q.priorj[1]))/2
  tau.log.q           <- pow(sd.log.q,-2)
  q                   ~  dlnorm(log.qm,tau.log.q)

  # define process (tau) and observation (sigma) variances as inversegamma priors
  itau2 ~ dgamma(4,0.01)
  tau2  <- 1/itau2
  tau   <- pow(tau2,0.5)

  isigma2 ~ dgamma(2,0.01)
  sigma2 <- 1/isigma2+pow(CV.cpue,2) # Add minimum realistic CPUE CV
  sigma  <- pow(sigma2,0.5)

  log.rm              <- mean(log(prior.r))
  sd.log.r            <- abs(log.rm - log(prior.r[1]))/2
  tau.log.r           <- pow(sd.log.r,-2)

  # bias-correct lognormal for k
  log.km              <- mean(log(prior.k))
  sd.log.k            <- abs(log.km-log(prior.k[1]))/2
  tau.log.k           <- pow(sd.log.k,-2)

  # Construct Multivariate lognormal (MVLN) prior
  mu.rk[1] <- log.rm
  mu.rk[2] <- log.km

  # Prior for correlation log(r) vs log(k)
  #><>MSY: now directly taken from mvn of ki = 4*msyi/ri
  rho <- rk.cor

  # Construct Covariance matrix
  cov.rk[1,1] <- sd.log.r * sd.log.r
  cov.rk[1,2] <- rho
  cov.rk[2,1] <- rho
  cov.rk[2,2] <- sd.log.k * sd.log.k

  # MVLN prior for r-k
  log.rk[1:2] ~ dmnorm(mu.rk[],inverse(cov.rk[,]))
  r <- exp(log.rk[1])
  k <- exp(log.rk[2])

  #><>MSY get posterior predictive distribution for rk
  ppd.logrk[1:2] ~ dmnorm(mu.rk[],inverse(cov.rk[,]))

  # ><>HW: Get B/Bmsy and F/Fmsy directly from JAGS
  Bmsy <- k/2
  Fmsy <- r/2
  for (t in 1:nyr){
  B[t] <- P[t]*k # biomass
  F[t] <- ct.jags[t]/B[t]
  BBmsy[t] <- P[t]*2 #true for Schaefer
  FFmsy[t] <- ifelse(BBmsy[t]<0.5,F[t]/(Fmsy*2*BBmsy[t]),F[t]/Fmsy)
  }
} "    
  
  cat(Model, file="r2jags.bug")

  #><>MSY: change to lognormal inits (better)
  j.inits <- function(){list("log.rk"=c(rnorm(1,mean=log(init.r),sd=0.2),rnorm(1,mean=log(init.k),sd=0.1)),
                             "q"=rlnorm(1,mean=log(init.q),sd=0.2),"itau2"=1000,"isigma2"=1000)}
  # run model ----
  jags_outputs <- jags.parallel(data=jags.data,
                                working.directory=NULL, inits=j.inits,
                                parameters.to.save=jags.save.params,
                                model.file="r2jags.bug", n.chains = n.chains,
                                n.burnin = 30000, n.thin = 10,
                                n.iter = 60000)
  return(jags_outputs)
}

get_beta <- function(mu,CV,Min=0,Prior="x",Plot=FALSE){
  a = seq(0.0001,1000,0.001)
  b= (a-mu*a)/mu
  s2 = a*b/((a+b)^2*(a+b+1))
  sdev = sqrt(s2)
  # find beta parameter a
  CV.check = (sdev/mu-CV)^2
  a = a[CV.check==min(CV.check)]
  # find beta parameter b
  b = (a-mu*a)/mu
  x = seq(Min,1,0.001)
  pdf = dbeta(x,a,b)
  if(Plot==TRUE){
    plot(x,pdf,type="l",xlim=range(x[pdf>0.01]),xlab=paste(Prior),ylab="",yaxt="n")
    polygon(c(x,rev(x)),c(rep(0,length(x)),rev(ifelse(pdf==Inf,100000,pdf))),col="grey")
  }
  return(c(a,b))
}

#><> convert b.prior ranges into beta priors
beta.prior = function(b.prior){
  bk.beta = matrix(0,nrow = 3,ncol=3)
  for(i in 1:3){
    sd.bk = (b.prior[2,i]-b.prior[1,i])/(4*0.98)
    mu.bk = mean(b.prior[1:2,i])
    cv.bk = sd.bk/mu.bk
    bk.beta[1:2,i] = get_beta(mu.bk,cv.bk)
  }
  return(bk.beta)
}

#Fits an ellipse around the CMSY r-k cloud and estimates the rightmost focus
traceEllipse<-function(rs,ks,prior.r,prior.k){
  log.rs<-log(rs)
  log.ks<-log(ks)

#  #select data within the bounding box
#  log.rs<-log.rs[which(rs>prior.r[1] & rs<prior.r[2] &
#                         ks>prior.k[1] & ks<prior.k[2]
#  )]
#  log.ks<-log.ks[which(rs>prior.r[1] & rs<prior.r[2] &
#                         ks>prior.k[1] & ks<prior.k[2]
#  )]

  #prepare data for ellipse fitting
  cloud.data <- as.matrix(data.frame(x = log.rs, y = log.ks))
  ellip <- EllipseDirectFit(cloud.data)
  #estimate ellipse characteristics
  atog<-AtoG(ellip)
  ellipG <- atog$ParG
  ell.center.x<-ellipG[1]
  ell.center.y<-ellipG[2]
  ell.axis.a<-ellipG[3]
  ell.axis.b<-ellipG[4]
  ell.tilt.angle.deg<-180/pi*ellipG[5]
  ell.slope<-tan(ellipG[5])
  xy.ell<-calculateEllipse(ell.center.x,
                           ell.center.y,
                           ell.axis.a,
                           ell.axis.b,
                           ell.tilt.angle.deg)
  #draw ellipse
  #points(x=xy.ell[,1],y=xy.ell[,2],col='red',type='l')
  ell.intercept.1 = ell.center.y-ell.center.x*ell.slope
  #draw ellipse main axis
  #abline(a =ell.intercept.1, b=ell.slope,col='red')
  #calculate focus from demi-axes
  ell.demiaxis.c.sqr<-(0.25*ell.axis.a*ell.axis.a)-(0.25*ell.axis.b*ell.axis.b)
  if (ell.demiaxis.c.sqr<0)
    ell.demiaxis.c.sqr<-ell.axis.a/2
  else
    ell.demiaxis.c<-sqrt(ell.demiaxis.c.sqr)
  sin.c<-ell.demiaxis.c*sin(ellipG[5])
  cos.c<-ell.demiaxis.c*cos(ellipG[5])
  ell.foc.y<-ell.center.y-sin.c
  ell.foc.x<-ell.center.x-cos.c


  return (c(exp(ell.foc.x),exp(ell.foc.y)))
}
#---------------------------------------------
# END OF FUNCTIONS
#---------------------------------------------

cat("-------------------------------------------\n")
cat("CMSY++ Analysis,", date(),"\n")
cat("-------------------------------------------\n")

```




JABBA {data-icon="fa-home"}
================================

Column {.sidebar}
------------------------------------------------------

### Inputs

```{r}
selectInput('region',
            label = 'Region',
            choices = c('1-Western Coast','2-Southern Coast'),
            selected = '1-Southern Coast')
selectInput('fleet',
            label = 'Fleet',
            choices = c('1-Polyvalent', '2-Bottom Trawl'),
            selected = '1-Polyvalent')
selectInput('model',
            label = 'Formulation',
            choices = c('Schaefer', 'Pella', 'Fox'),
            selected = 'Schaefer')
numericInput('jabba_p_lim',
            label = 'P_lim',
            value = 0.5)

dados = reactive({
  df_effort_y %>% filter(fill == paste(input$region, input$fleet))
})

jbinput = reactive({
  build_jabba(catch = data.frame('Year' = dados()$year_sale %>% as.numeric(),
                                         'mis' = dados()$catch),
                      cpue = data.frame('Year' = dados()$year_sale %>% as.numeric(),
                                        'mis' = dados()$lpue),
                      se = data.frame('Year' = dados()$year_sale %>% as.numeric(),
                                        'mis' = log(dados()$sd/dados()$lpue)),
                      scenario = 'TestRun',
                      model.type = input$model,
                      sigma.est = F,
                      fixed.obsE = 0.01,
                      Plim = input$jabba_p_lim)
})
  
bet_total = reactive({
  fit_jabba(jbinput(),
                    ni = 30000, #number of iterations 
                    nt = 5, # thinning interval of saved iterations
                    nb = 5000, #burn-in
                    nc = 2, #number of mcmc chains initial values
                    init.values = FALSE, # 
                    init.K = NULL,
                    init.r = 0.81,
                    init.q = NULL,
                    peels = NULL, # NULL, # retro peel option
                    do.ppc = TRUE, # conducts and saves posterior predictive checks
                    save.trj = TRUE, # adds posteriors of stock, harvest and bk trajectories
                    save.all = FALSE, # add complete posteriors to fitted object
                    save.jabba = FALSE, # saves jabba fit as rdata object
                    save.csvs = FALSE, # option to write csv outputs
                    # output.dir = '/',
                    quickmcmc = TRUE,
                    seed = 123,
                    jagsdir = NULL,
                    verbose = TRUE)  

})
```

Row { data-height=20 }
--------------------------------

### Portuguese Coast, 1995-2022
```{r}
valueBox(paste("Octopus Fisheries in Portugal"),
         color="steelblue")
```


Row {data-width=325}
--------------------------------

### Grafico sexy

```{r}
renderPlot({
par(mfrow = c(2,2), mar = c(5, 5, 5, 5))
jbplot_trj(bet_total(),type="BBmsy", add = T)
jbplot_trj(bet_total(),type="FFmsy", add = T)
jbplot_kobe(bet_total(), add = T)
jbplot_spphase(bet_total(), add = T)
})
```


```


